%we test for the accuracy of the forward transform problem.

%we use as our test function g=x, h=x^2. these can be analytically
%integrated using mathematica easily.

%we test using linear_spline_linear_spacing.m, and different values of n

%analytic integration is achieved easily by using our test functions.

%sets the limits for analytic integration
infinity = 10^(10);
epsilon = 0;

%sets the analytic integrals K11, K12, K21, K22 for a defined z and x,
%integrating against the functions:
%so K11 multipled by x, K12 by x^2, K21 by x, K22 by x^2

K11x1int = @(x,z) real(4.*(4+3.*x.^2+(-4).*x.*z+z.^2).*(4+x.^2+(-2).*x.*z+z.^2).^(-2));

K11sqrtx0int = @(x,z) real(2.*x.^(1/2).*(4+z.^2).^(-2).*(4+x.^2+(-2).*x.*z+z.^2).^(-2).*(6.* ...
...
  x.^3.*z+x.^2.*(4+(-23).*z.^2)+32.*x.*(z+z.^3)+(-5).*((-16)+8.* ...
 ...
 z.^2+3.*z.^4))+(sqrt(-1)*(3/2)).*((sqrt(-1)*(-2))+(-1).*z).^(-5/2) ...
...
  .*atan(x.^(1/2).*((sqrt(-1)*(-2))+(-1).*z).^(-1/2))+(sqrt(-1)*( ...
...
  -3/2)).*((sqrt(-1)*2)+(-1).*z).^(-5/2).*atan(x.^(1/2).*((sqrt(-1)* ...
...
  2)+(-1).*z).^(-1/2)));

K12x1int = @(x,z) real(2.*(4+(x+(-1).*z).^2).^(-2).*((-8).*x+(-1).*(4+(x+(-1).*z).^2).*z) ...
  +(1/2).*z.*log(4+(x+(-1).*z).^2)+(-1).*z.*log(x+(-1).*z));

K12sqrtx0int = @(x,z) real((1/2).*(2.*x.^(1/2).*(4+(x+(-1).*z).^2).^(-2).*(4+z.^2).^(-2).*( ...
 ...
 16.*(x+(-2).*z).*(4+z.^2)+(4+x.^2+(-2).*x.*z+z.^2).*((-3).*z.*(20+ ...
...
  z.^2)+x.*(28+z.^2)))+((sqrt(-1)*2)+(-1).*z).^(-5/2).*((-15)+(sqrt( ...
...
  -1)*(-10)).*z+2.*z.^2).*atan(x.^(1/2).*((sqrt(-1)*2)+(-1).*z).^( ...
...
  -1/2))+4.*z.^(-1/2).*atanh(x.^(1/2).*z.^(-1/2))+(-1).*((sqrt(-1)* ...
...
  2)+z).^(-5/2).*((-15)+(sqrt(-1)*10).*z+2.*z.^2).*atanh(x.^(1/2).*( ...
...
  (sqrt(-1)*2)+z).^(-1/2))));

K21x1int = @(x,z) -real(16.*x.*(4+(x+(-1).*z).^2).^(-2)+(-8).*x.*(4+(x+(-1).*z).^2).^(-1)+ ...
  2.*(4+(x+(-1).*z).^2).^(-1).*z+4.*atan((1/2).*(x+(-1).*z))+(-1/2) ...
  .*z.*log(4+(x+(-1).*z).^2)+z.*log(x+(-1).*z));

K21sqrtx0int = @(x,z) -real((1/2).*(2.*x.^(1/2).*(4+(x+(-1).*z).^2).^(-2).*(4+z.^2).^(-2).*(( ...
...
  -16).*(x+(-2).*z).*(4+z.^2)+(4+x.^2+(-2).*x.*z+z.^2).*(4.*x+(-4).* ...
...
  z+7.*x.*z.^2+(-13).*z.^3))+(-1).*((sqrt(-1)*2)+(-1).*z).^(-5/2).*( ...
...
  (-7)+(sqrt(-1)*(-6)).*z+2.*z.^2).*atan(x.^(1/2).*((sqrt(-1)*2)+( ...
...
  -1).*z).^(-1/2))+(-4).*z.^(-1/2).*atanh(x.^(1/2).*z.^(-1/2))+(( ...
...
  sqrt(-1)*2)+z).^(-5/2).*((-7)+(sqrt(-1)*6).*z+2.*z.^2).*atanh(x.^( ...
...
  1/2).*((sqrt(-1)*2)+z).^(-1/2))));

K22x1int = @(x,z) -real(4.*(4+3.*x.^2+(-4).*x.*z+z.^2).*(4+x.^2+(-2).*x.*z+z.^2).^(-2));

K22sqrtx0int = @(x,z) -real(2.*x.^(1/2).*(4+z.^2).^(-2).*(4+x.^2+(-2).*x.*z+z.^2).^(-2).*(6.* ...
...
  x.^3.*z+x.^2.*(4+(-23).*z.^2)+32.*x.*(z+z.^3)+(-5).*((-16)+8.* ...
 ...
 z.^2+3.*z.^4))+(sqrt(-1)*(3/2)).*((sqrt(-1)*(-2))+(-1).*z).^(-5/2) ...
...
  .*atan(x.^(1/2).*((sqrt(-1)*(-2))+(-1).*z).^(-1/2))+(sqrt(-1)*( ...
...
  -3/2)).*((sqrt(-1)*2)+(-1).*z).^(-5/2).*atan(x.^(1/2).*((sqrt(-1)* ...
...
  2)+(-1).*z).^(-1/2)));

%sets the trial n for discretization

n = [100,140,200,280,400];
t = round(n/2);

x = zeros(length(n),max(n));
z = zeros(length(n),max(n)-1);

g = @(x) x + 1/sqrt(x);
h = @(x) x + 1/sqrt(x);

gvector = zeros(length(n),max(n));
hvector = zeros(length(n),max(n));

pressure_num = zeros(length(n),max(n)-1);
shear_num = zeros(length(n),max(n)-1);
pressure_an = zeros(length(n),max(n)-1);
shear_an = zeros(length(n),max(n)-1);

total_error_pressure = zeros(1,length(n));
total_error_shear = zeros(1,length(n));
max_error_pressure = zeros(1,length(n));
max_error_shear = zeros(1,length(n));

endpoint = 30;

for i=1:length(n)
    [KI, KII, conditioning, soln, gprime, hprime, inpoint, outpoint, ...
        Pmatrix, interpol, gcoeffmatrix, hcoeffmatrix] ...
    = linear_spline_linear_spacing(n(i), endpoint, 0, 1);
    x(i,1:n(i)) = inpoint;
    z(i,1:n(i)-1) = outpoint;
    
    for j=1:t(i)
        gvector(i,j) = x(i,j)^(3/2) + 1;
        hvector(i,j) = x(i,j)^(3/2) + 1;
    end
    for j=t(i)+1:n(i)
        gvector(i,j) = g(x(i,j));
        hvector(i,j) = h(x(i,j));
    end
    
    %computes the numerical pressure
    input = zeros(2*n(i),1);
    input(1:n(i),1) = gvector(i,1:n(i));
    input(n(i)+1:2*n(i),1) = hvector(i,1:n(i));
    
    output = Pmatrix*input;
    pressure_num(i,1:n(i)-1) = output(1:n(i)-1);
    shear_num(i,1:n(i)-1) = output(n(i):2*n(i)-2);
    
    %computes the analytic pressure
    for j=1:n(i)-1
        pressure_an(i,j) = K11x1int(infinity,z(i,j)) - K11x1int(epsilon,z(i,j)) ...
            + K11sqrtx0int(infinity,z(i,j)) - K11sqrtx0int(epsilon, z(i,j)) ...
            + K12x1int(infinity, z(i,j)) - K12x1int(epsilon, z(i,j)) ...
            + K12sqrtx0int(infinity,z(i,j)) - K12sqrtx0int(epsilon, z(i,j));
        shear_an(i,j) = K21x1int(infinity, z(i,j)) - K21x1int(epsilon,z(i,j)) ...
            + K21sqrtx0int(infinity,z(i,j)) - K21sqrtx0int(epsilon,z(i,j)) ...
            + K22x1int(infinity, z(i,j)) - K22x1int(epsilon, z(i,j)) ...
            + K22sqrtx0int(infinity,z(i,j)) - K22sqrtx0int(epsilon, z(i,j));
    end
    
    total_error_pressure(i) = norm(pressure_an(i,:) - pressure_num(i,:))/sqrt(n(i));
    total_error_shear(i) = norm(shear_an(i,:) - shear_num(i,:))/sqrt(n(i));
    
    max_error_pressure(i) = max(abs(pressure_an(i,:) - pressure_num(i,:)));
    max_error_shear(i) = max(abs(shear_an(i,:) - shear_num(i,:)));
end
    


