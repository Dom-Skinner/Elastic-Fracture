function kernel_matrix = pressure_matrix_g(v,w,t,lambda)

nv = length(v);
nw = length(w);

infinity = 10^10;

interpolate_matrix = linear_simpleinfty_interpolate_g(v,t,lambda);
function_matrix = zeros(nw,2*nv);


%FINDS ALL THE KERNEL FUNCTIONS

K11x1 = @(x,z) real(4.*(4+3.*x.^2+(-4).*x.*z+z.^2).* ...
    (4+x.^2+(-2).*x.*z+z.^2).^(-2));
  
K11x0 = @(x,z) real(8.*(4+(x+(-1).*z).^2).^(-2).*(x+(-1).*z));


K11sqrtx1 = @(x,z,at,at2) real((-2).*x.^(1/2).*(4+z.^2).^(-1).* ...
    ... 
    (4+x.^2+(-2).*x.*z+z.^2).^(-2).*( ...
    ...
    x.^3+(-4).*x.^2.*z+x.*((-12)+z.^2)+2.*z.*(4+z.^2))+(sqrt(-1)*(1/2) ...
    ...
    ).*((sqrt(-1)*(-2))+(-1).*z).^(-3/2).*at2+(sqrt(-1)*(-1/2)) ...
    ...
    .*((sqrt(-1)*2)+(-1).*z).^(-3/2).*at);
  
  
K11sqrtx0 = @(x,z,at,at2) real(2.*x.^(1/2).*(4+z.^2).^(-2).* ...
    ...
    (4+x.^2+(-2).*x.*z+z.^2).^(-2).*(6.* ...
    ...
    x.^3.*z+x.^2.*(4+(-23).*z.^2)+32.*x.*(z+z.^3)+(-5).*((-16)+8.* ...
    ...
    z.^2+3.*z.^4))+(sqrt(-1)*(3/2)).*((sqrt(-1)*(-2))+(-1).*z).^(-5/2) ...
    ...
    .*at2+(sqrt(-1)*(-3/2)).*((sqrt(-1)*2)+(-1).*z).^(-5/2).*at);


for i=1:nw
    %goes over the 1/sqrt(x) panels
    % All code vectorised for speed. Common expresions computed first.
    x_t = v(1:t);
    %
    atan_store_1 = atan(x_t.^(1/2).*((sqrt(-1)*2)+(-1)*w(i)).^(-1/2));
    atan_store_2 = atan(x_t.^(1/2).*((sqrt(-1)*(-2))+(-1)*w(i)).^(-1/2));
    %
   
    K11sqrtx1_store = K11sqrtx1(x_t,w(i),atan_store_1,atan_store_2); 
    K11sqrtx0_store = K11sqrtx0(x_t,w(i),atan_store_1,atan_store_2); 

   
    j=1:t-1;
    %for K11
    function_matrix(i,j)      = K11sqrtx1_store(j+1)-K11sqrtx1_store(j);
    function_matrix(i,nv+j)   = K11sqrtx0_store(j+1)-K11sqrtx0_store(j);
  
   
    %goes over the linear panels including infinity
    x_tmp = [v(t:nv) infinity];
    K11x1_store = K11x1(x_tmp,w(i));
    K11x0_store = K11x0(x_tmp,w(i));  
    %
    j=1:nv-t+1;
    % for K11
    function_matrix(i,j+t-1)     = K11x1_store(j+1)-K11x1_store(j);
    function_matrix(i,nv+j+t-1)  = K11x0_store(j+1)-K11x0_store(j);

  
end        

%kernel_matrix = function_matrix*interpolate_matrix;

% The following lines are equivalent to:
%h_co_mat = h_coeff_mat*interpolate_matrix;
% But we know that the interpolate matrix is essentially diagonal, so we
% can save ourselves time by doing the multiplication ourselves
kernel_matrix = zeros(nw,nv);
kernel_matrix(:,1) = ...
    interpolate_matrix(1,1)*function_matrix(:,1)+...
    + interpolate_matrix(nv+1,1)*function_matrix(:,nv+1);
for k = 2:nv-2
    kernel_matrix(:,k) = ...
        interpolate_matrix(k,k)    *function_matrix(:,k)   + ...
        interpolate_matrix(k-1,k)  *function_matrix(:,k-1) + ...
        interpolate_matrix(nv+k,k)  *function_matrix(:,nv+k) + ...
        interpolate_matrix(nv+k-1,k)*function_matrix(:,nv+k-1);
end
kernel_matrix(:,nv-1) = ...
    interpolate_matrix(nv-2,nv-1)  *function_matrix(:,nv-2)   + ...
    interpolate_matrix(nv-1,nv-1)  *function_matrix(:,nv-1)   + ...
    interpolate_matrix(nv,nv-1)    *function_matrix(:,nv)     + ...
    interpolate_matrix(2*nv-2,nv-1)*function_matrix(:,2*nv-2) + ...
    interpolate_matrix(2*nv-1,nv-1)*function_matrix(:,2*nv-1) + ...
    interpolate_matrix(2*nv,nv-1)  *function_matrix(:,2*nv);

kernel_matrix(:,nv) = ...
    interpolate_matrix(nv-1,nv)  *function_matrix(:,nv-1)     + ...
    interpolate_matrix(nv,nv)    *function_matrix(:,nv)       + ...
    interpolate_matrix(2*nv-1,nv)*function_matrix(:,2*nv-1)   + ...
    interpolate_matrix(2*nv,nv)  *function_matrix(:,2*nv);

return
end
    